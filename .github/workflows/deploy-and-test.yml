name: Deploy and Test

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      video:
        description: 'Video to test'
        required: true
        default: 'adam'
        type: choice
        options:
          - adam
          - angela
          - audrey

env:
  AWS_REGION: us-east-2
  ECR_REPOSITORY: multimodal-transcription
  S3_BUCKET: multimodal-transcription-videos-1761690600
  ECS_CLUSTER: multimodal-transcription-cluster
  VPC_ID: vpc-f2452499
  SUBNET_IDS: subnet-9b7957d7,subnet-e74bc28c,subnet-8135f2fc
  SECURITY_GROUP_ID: sg-0b638085b666a013f

jobs:
  deploy-and-test:
    name: Deploy and Test
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Set video path
      id: video-path
      run: |
        case "${{ github.event.inputs.video || 'adam' }}" in
          "adam")
            echo "video-path=test-videos/Adam_2024-03-03_6_32_PM.mp4" >> $GITHUB_OUTPUT
            echo "video-name=Adam" >> $GITHUB_OUTPUT
            ;;
          "angela")
            echo "video-path=test-videos/Angela_2025-03-10_2_11_PM.mp4" >> $GITHUB_OUTPUT
            echo "video-name=Angela" >> $GITHUB_OUTPUT
            ;;
          "audrey")
            echo "video-path=test-videos/Audrey_2025-04-06_6_20_PM-2.mp4" >> $GITHUB_OUTPUT
            echo "video-name=Audrey" >> $GITHUB_OUTPUT
            ;;
        esac

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build and push Docker image
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        echo "Building Docker image..."
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        echo "Pushing to ECR..."
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        echo "image-uri=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

    - name: Create ECS cluster if it doesn't exist
      run: |
        echo "üîß Ensuring ECS cluster exists..."
        aws ecs describe-clusters --clusters ${{ env.ECS_CLUSTER }} || \
        aws ecs create-cluster --cluster-name ${{ env.ECS_CLUSTER }}

    - name: Create dynamic task definition
      id: task-def
      run: |
        TIMESTAMP=$(date +%Y%m%d_%H%M%S)
        OUTPUT_PREFIX="test-outputs/${{ steps.video-path.outputs.video-name }}-$TIMESTAMP"
        
        echo "üé¨ Testing video: ${{ steps.video-path.outputs.video-name }}"
        echo "üìÅ S3 output: s3://${{ env.S3_BUCKET }}/$OUTPUT_PREFIX/"
        
        # Create dynamic task definition
        cat > temp-task-definition.json << EOF
        {
          "family": "multimodal-transcription-test-$(date +%s)",
          "networkMode": "awsvpc",
          "requiresCompatibilities": ["FARGATE"],
          "cpu": "2048",
          "memory": "4096",
          "executionRoleArn": "arn:aws:iam::669655810547:role/ecsTaskExecutionRole",
          "containerDefinitions": [
            {
              "name": "multimodal-transcription",
              "image": "${{ steps.build-image.outputs.image-uri }}",
              "essential": true,
              "logConfiguration": {
                "logDriver": "awslogs",
                "options": {
                  "awslogs-group": "/ecs/multimodal-transcription-test",
                  "awslogs-region": "${{ env.AWS_REGION }}",
                  "awslogs-stream-prefix": "ecs"
                }
              },
              "environment": [
                {
                  "name": "PYTHONUNBUFFERED",
                  "value": "1"
                },
                {
                  "name": "AWS_DEFAULT_REGION",
                  "value": "${{ env.AWS_REGION }}"
                }
              ],
              "secrets": [
                {
                  "name": "GOOGLE_API_KEY",
                  "valueFrom": "arn:aws:secretsmanager:${{ env.AWS_REGION }}:669655810547:secret:google-api-key"
                }
              ],
              "command": [
                "python",
                "src/transcription_pipeline.py",
                "--input",
                "s3://${{ env.S3_BUCKET }}/${{ steps.video-path.outputs.video-path }}",
                "--output-dir",
                "s3://${{ env.S3_BUCKET }}/$OUTPUT_PREFIX",
                "--chunk-size",
                "600",
                "--max-workers",
                "2",
                "--verbose"
              ]
            }
          ]
        }
        EOF
        
        echo "OUTPUT_PREFIX=$OUTPUT_PREFIX" >> $GITHUB_ENV
        echo "output-prefix=$OUTPUT_PREFIX" >> $GITHUB_OUTPUT

    - name: Register and run ECS task
      run: |
        echo "üìã Registering task definition..."
        TASK_DEF_ARN=$(aws ecs register-task-definition \
          --cli-input-json file://temp-task-definition.json \
          --query 'taskDefinition.taskDefinitionArn' \
          --output text)
        
        echo "‚úÖ Task definition registered: $TASK_DEF_ARN"
        
        echo "üöÄ Starting ECS task..."
        TASK_ARN=$(aws ecs run-task \
          --cluster ${{ env.ECS_CLUSTER }} \
          --task-definition $TASK_DEF_ARN \
          --launch-type FARGATE \
          --network-configuration "awsvpcConfiguration={subnets=[${{ env.SUBNET_IDS }}],securityGroups=[${{ env.SECURITY_GROUP_ID }}],assignPublicIp=ENABLED}" \
          --query 'tasks[0].taskArn' \
          --output text)
        
        echo "‚úÖ ECS task started: $TASK_ARN"
        
        # Wait for task to complete
        echo "‚è≥ Waiting for task to complete..."
        aws ecs wait tasks-stopped \
          --cluster ${{ env.ECS_CLUSTER }} \
          --tasks $TASK_ARN
        
        # Get task status
        TASK_STATUS=$(aws ecs describe-tasks \
          --cluster ${{ env.ECS_CLUSTER }} \
          --tasks $TASK_ARN \
          --query 'tasks[0].lastStatus' \
          --output text)
        
        EXIT_CODE=$(aws ecs describe-tasks \
          --cluster ${{ env.ECS_CLUSTER }} \
          --tasks $TASK_ARN \
          --query 'tasks[0].containers[0].exitCode' \
          --output text)
        
        if [ "$TASK_STATUS" = "STOPPED" ] && [ "$EXIT_CODE" = "0" ]; then
          echo "‚úÖ ECS task completed successfully!"
        else
          echo "‚ùå ECS task failed with status: $TASK_STATUS, exit code: $EXIT_CODE"
          
          # Get task logs for debugging
          echo "üìã Fetching task logs..."
          LOG_STREAM_NAME=$(aws logs describe-log-streams \
            --log-group-name "/ecs/multimodal-transcription-test" \
            --log-stream-name-prefix "ecs/multimodal-transcription/$TASK_ARN" \
            --query 'logStreams[0].logStreamName' \
            --output text)
          
          if [ "$LOG_STREAM_NAME" != "None" ] && [ ! -z "$LOG_STREAM_NAME" ]; then
            aws logs get-log-events \
              --log-group-name "/ecs/multimodal-transcription-test" \
              --log-stream-name "$LOG_STREAM_NAME" \
              --start-from-head \
              --query 'events[*].message' \
              --output text | tail -20
          fi
          
          exit 1
        fi
        
        # Clean up temporary file
        rm -f temp-task-definition.json

    - name: Clean up old ECR images
      run: |
        echo "üßπ Cleaning up old ECR images..."
        
        # Get current image digest using the image URI
        CURRENT_IMAGE_DIGEST=$(aws ecr describe-images --repository-name ${{ env.ECR_REPOSITORY }} --region ${{ env.AWS_REGION }} --query 'imageDetails[0].imageDigest' --output text)
        
        if [ "$CURRENT_IMAGE_DIGEST" != "None" ] && [ ! -z "$CURRENT_IMAGE_DIGEST" ]; then
          echo "Current image digest: $CURRENT_IMAGE_DIGEST"
          
          # List all images except the current one
          ALL_IMAGES=$(aws ecr list-images --repository-name ${{ env.ECR_REPOSITORY }} --region ${{ env.AWS_REGION }} --query 'imageIds[?imageDigest!=`'$CURRENT_IMAGE_DIGEST'`].imageDigest' --output text)
          
          if [ ! -z "$ALL_IMAGES" ]; then
            echo "Deleting old images..."
            for digest in $ALL_IMAGES; do
              echo "Deleting: $digest"
              aws ecr batch-delete-image --repository-name ${{ env.ECR_REPOSITORY }} --region ${{ env.AWS_REGION }} --image-ids imageDigest=$digest || echo "Failed to delete $digest (may be referenced by manifest list)"
            done
          else
            echo "No old images to clean up"
          fi
        else
          echo "No current image found, skipping cleanup"
        fi
        
        echo "‚úÖ ECR cleanup completed"

    - name: Clean up unused CloudWatch log groups
      run: |
        echo "üßπ Cleaning up unused CloudWatch log groups..."
        
        # List of log groups to clean up (keep only the ones we're using)
        LOG_GROUPS_TO_DELETE=(
          "/ecs/multimodal-transcription-simple"
          "/ecs/batch-transcription"
        )
        
        for log_group in "${LOG_GROUPS_TO_DELETE[@]}"; do
          echo "Checking log group: $log_group"
          if aws logs describe-log-groups --log-group-name-prefix "$log_group" --region ${{ env.AWS_REGION }} --query 'logGroups[0].logGroupName' --output text | grep -q "$log_group"; then
            echo "Deleting log group: $log_group"
            aws logs delete-log-group --log-group-name "$log_group" --region ${{ env.AWS_REGION }} || echo "Failed to delete $log_group (may have active streams)"
          else
            echo "Log group $log_group not found or already deleted"
          fi
        done
        
        echo "‚úÖ CloudWatch cleanup completed"

    - name: Show results
      run: |
        echo "‚úÖ ECS test completed successfully!"
        echo "üé¨ Video: ${{ steps.video-path.outputs.video-name }}"
        echo "üì¶ Image: ${{ steps.build-image.outputs.image-uri }}"
        echo "üìÅ Results: s3://${{ env.S3_BUCKET }}/${{ steps.task-def.outputs.output-prefix }}/"
        echo "üèóÔ∏è ECS Cluster: ${{ env.ECS_CLUSTER }}"
        echo ""
        echo "üìã S3 Output files:"
        aws s3 ls "s3://${{ env.S3_BUCKET }}/${{ steps.task-def.outputs.output-prefix }}/" --recursive || echo "No files found"
